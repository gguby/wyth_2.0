//
// ConnectcontrollerAPI.swift
//
// Generated by swagger-codegen
// Modified by dk (dk@devrock.co.kr)
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Alamofire
import RxSwift



open class ConnectcontrollerAPI {
  private static var xAPPVersion: String = BSTApplication.shortVersion ?? "unknown"
  private static var xDevice: String     = "ios"
  private static var acceptLanguage: String = "ko-KR"
    /**
     connect
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func connectUsingPOST(providerId: String, completion: @escaping ((_ data: RedirectView?,_ error: Error?) -> Void)) {
        connectUsingPOSTWithRequestBuilder(providerId: providerId).execute { (response, error) -> Void in
            completion(response?.body, BSTErrorBaker.errorFilter(error, response))
        }
    }

    /**
     connect
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - returns: Observable<RedirectView>
     */
    open class func connectUsingPOST(providerId: String) -> Observable<RedirectView> {
        return Observable.create { observer -> Disposable in
            connectUsingPOST(providerId: providerId) { data, error in
                if let error = error {
                    observer.on(.error(BSTErrorBaker<Any>.errorFilter(error)!))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     connect
     - POST /connect/{providerId}
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 

     - returns: RequestBuilder<RedirectView> 
     */
    open class func connectUsingPOSTWithRequestBuilder(providerId: String) -> RequestBuilder<RedirectView> {
        var path = "/connect/{providerId}"
        path = path.replacingOccurrences(of: "{providerId}", with: "\(providerId)", options: .literal, range: nil)
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RedirectView>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

    /**
     connectionStatus
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func connectionStatusUsingGET1(completion: @escaping ((_ data: String?,_ error: Error?) -> Void)) {
        connectionStatusUsingGET1WithRequestBuilder().execute { (response, error) -> Void in
            completion(response?.body, BSTErrorBaker.errorFilter(error, response))
        }
    }

    /**
     connectionStatus
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - returns: Observable<String>
     */
    open class func connectionStatusUsingGET1() -> Observable<String> {
        return Observable.create { observer -> Disposable in
            connectionStatusUsingGET1() { data, error in
                if let error = error {
                    observer.on(.error(BSTErrorBaker<Any>.errorFilter(error)!))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     connectionStatus
     - GET /connect
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 

     - returns: RequestBuilder<String> 
     */
    open class func connectionStatusUsingGET1WithRequestBuilder() -> RequestBuilder<String> {
        let path = "/connect"
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<String>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

    /**
     oauth2Callback
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter code: (query)  
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func oauth2CallbackUsingGET(providerId: String, code: String, completion: @escaping ((_ data: RedirectView?,_ error: Error?) -> Void)) {
        oauth2CallbackUsingGETWithRequestBuilder(providerId: providerId, code: code).execute { (response, error) -> Void in
            completion(response?.body, BSTErrorBaker.errorFilter(error, response))
        }
    }

    /**
     oauth2Callback
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter code: (query)  
     - returns: Observable<RedirectView>
     */
    open class func oauth2CallbackUsingGET(providerId: String, code: String) -> Observable<RedirectView> {
        return Observable.create { observer -> Disposable in
            oauth2CallbackUsingGET(providerId: providerId, code: code) { data, error in
                if let error = error {
                    observer.on(.error(BSTErrorBaker<Any>.errorFilter(error)!))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     oauth2Callback
     - GET /connect/{providerId}
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter code: (query)  

     - returns: RequestBuilder<RedirectView> 
     */
    open class func oauth2CallbackUsingGETWithRequestBuilder(providerId: String, code: String) -> RequestBuilder<RedirectView> {
        var path = "/connect/{providerId}"
        path = path.replacingOccurrences(of: "{providerId}", with: "\(providerId)", options: .literal, range: nil)
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "code": code
        ])
        
        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RedirectView>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

    /**
     removeConnection
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter providerUserId: (path) providerUserId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func removeConnectionUsingDELETE(providerId: String, providerUserId: String, completion: @escaping ((_ data: RedirectView?,_ error: Error?) -> Void)) {
        removeConnectionUsingDELETEWithRequestBuilder(providerId: providerId, providerUserId: providerUserId).execute { (response, error) -> Void in
            completion(response?.body, BSTErrorBaker.errorFilter(error, response))
        }
    }

    /**
     removeConnection
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter providerUserId: (path) providerUserId 
     - returns: Observable<RedirectView>
     */
    open class func removeConnectionUsingDELETE(providerId: String, providerUserId: String) -> Observable<RedirectView> {
        return Observable.create { observer -> Disposable in
            removeConnectionUsingDELETE(providerId: providerId, providerUserId: providerUserId) { data, error in
                if let error = error {
                    observer.on(.error(BSTErrorBaker<Any>.errorFilter(error)!))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     removeConnection
     - DELETE /connect/{providerId}/{providerUserId}
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter providerUserId: (path) providerUserId 

     - returns: RequestBuilder<RedirectView> 
     */
    open class func removeConnectionUsingDELETEWithRequestBuilder(providerId: String, providerUserId: String) -> RequestBuilder<RedirectView> {
        var path = "/connect/{providerId}/{providerUserId}"
        path = path.replacingOccurrences(of: "{providerId}", with: "\(providerId)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{providerUserId}", with: "\(providerUserId)", options: .literal, range: nil)
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RedirectView>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

    /**
     removeConnections
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func removeConnectionsUsingDELETE(providerId: String, completion: @escaping ((_ data: RedirectView?,_ error: Error?) -> Void)) {
        removeConnectionsUsingDELETEWithRequestBuilder(providerId: providerId).execute { (response, error) -> Void in
            completion(response?.body, BSTErrorBaker.errorFilter(error, response))
        }
    }

    /**
     removeConnections
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - returns: Observable<RedirectView>
     */
    open class func removeConnectionsUsingDELETE(providerId: String) -> Observable<RedirectView> {
        return Observable.create { observer -> Disposable in
            removeConnectionsUsingDELETE(providerId: providerId) { data, error in
                if let error = error {
                    observer.on(.error(BSTErrorBaker<Any>.errorFilter(error)!))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     removeConnections
     - DELETE /connect/{providerId}
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 

     - returns: RequestBuilder<RedirectView> 
     */
    open class func removeConnectionsUsingDELETEWithRequestBuilder(providerId: String) -> RequestBuilder<RedirectView> {
        var path = "/connect/{providerId}"
        path = path.replacingOccurrences(of: "{providerId}", with: "\(providerId)", options: .literal, range: nil)
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RedirectView>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

}
