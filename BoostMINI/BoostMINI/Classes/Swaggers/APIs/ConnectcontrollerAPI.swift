//
// ConnectcontrollerAPI.swift
//
// Generated by swagger-codegen
// Modified by dk (dk@devrock.co.kr)
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Alamofire
import RxSwift



open class ConnectcontrollerAPI {
    /**
     connect
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func connectUsingPOST(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String, completion: @escaping ((_ data: RedirectView?,_ error: Error?) -> Void)) {
        connectUsingPOSTWithRequestBuilder(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage, providerId: providerId).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     connect
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - returns: Observable<RedirectView>
     */
    open class func connectUsingPOST(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String) -> Observable<RedirectView> {
        return Observable.create { observer -> Disposable in
            connectUsingPOST(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage, providerId: providerId) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     connect
     - POST /connect/{providerId}
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 

     - returns: RequestBuilder<RedirectView> 
     */
    open class func connectUsingPOSTWithRequestBuilder(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String) -> RequestBuilder<RedirectView> {
        var path = "/connect/{providerId}"
        path = path.replacingOccurrences(of: "{providerId}", with: "\(providerId)", options: .literal, range: nil)
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RedirectView>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

    /**
     connectionStatus
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func connectionStatusUsingGET1(xAPPVersion: String, xDevice: String, acceptLanguage: String, completion: @escaping ((_ data: String?,_ error: Error?) -> Void)) {
        connectionStatusUsingGET1WithRequestBuilder(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     connectionStatus
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - returns: Observable<String>
     */
    open class func connectionStatusUsingGET1(xAPPVersion: String, xDevice: String, acceptLanguage: String) -> Observable<String> {
        return Observable.create { observer -> Disposable in
            connectionStatusUsingGET1(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     connectionStatus
     - GET /connect
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 

     - returns: RequestBuilder<String> 
     */
    open class func connectionStatusUsingGET1WithRequestBuilder(xAPPVersion: String, xDevice: String, acceptLanguage: String) -> RequestBuilder<String> {
        let path = "/connect"
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<String>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

    /**
     oauth2Callback
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter code: (query)  
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func oauth2CallbackUsingGET(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String, code: String, completion: @escaping ((_ data: RedirectView?,_ error: Error?) -> Void)) {
        oauth2CallbackUsingGETWithRequestBuilder(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage, providerId: providerId, code: code).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     oauth2Callback
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter code: (query)  
     - returns: Observable<RedirectView>
     */
    open class func oauth2CallbackUsingGET(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String, code: String) -> Observable<RedirectView> {
        return Observable.create { observer -> Disposable in
            oauth2CallbackUsingGET(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage, providerId: providerId, code: code) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     oauth2Callback
     - GET /connect/{providerId}
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter code: (query)  

     - returns: RequestBuilder<RedirectView> 
     */
    open class func oauth2CallbackUsingGETWithRequestBuilder(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String, code: String) -> RequestBuilder<RedirectView> {
        var path = "/connect/{providerId}"
        path = path.replacingOccurrences(of: "{providerId}", with: "\(providerId)", options: .literal, range: nil)
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "code": code
        ])
        
        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RedirectView>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

    /**
     removeConnection
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter providerUserId: (path) providerUserId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func removeConnectionUsingDELETE(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String, providerUserId: String, completion: @escaping ((_ data: RedirectView?,_ error: Error?) -> Void)) {
        removeConnectionUsingDELETEWithRequestBuilder(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage, providerId: providerId, providerUserId: providerUserId).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     removeConnection
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter providerUserId: (path) providerUserId 
     - returns: Observable<RedirectView>
     */
    open class func removeConnectionUsingDELETE(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String, providerUserId: String) -> Observable<RedirectView> {
        return Observable.create { observer -> Disposable in
            removeConnectionUsingDELETE(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage, providerId: providerId, providerUserId: providerUserId) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     removeConnection
     - DELETE /connect/{providerId}/{providerUserId}
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter providerUserId: (path) providerUserId 

     - returns: RequestBuilder<RedirectView> 
     */
    open class func removeConnectionUsingDELETEWithRequestBuilder(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String, providerUserId: String) -> RequestBuilder<RedirectView> {
        var path = "/connect/{providerId}/{providerUserId}"
        path = path.replacingOccurrences(of: "{providerId}", with: "\(providerId)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{providerUserId}", with: "\(providerUserId)", options: .literal, range: nil)
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RedirectView>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

    /**
     removeConnections
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func removeConnectionsUsingDELETE(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String, completion: @escaping ((_ data: RedirectView?,_ error: Error?) -> Void)) {
        removeConnectionsUsingDELETEWithRequestBuilder(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage, providerId: providerId).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }

    /**
     removeConnections
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 
     - returns: Observable<RedirectView>
     */
    open class func removeConnectionsUsingDELETE(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String) -> Observable<RedirectView> {
        return Observable.create { observer -> Disposable in
            removeConnectionsUsingDELETE(xAPPVersion: xAPPVersion, xDevice: xDevice, acceptLanguage: acceptLanguage, providerId: providerId) { data, error in
                if let error = error {
                    observer.on(.error(error as Error))
                } else {
                    observer.on(.next(data!))
                }
                observer.on(.completed)
            }
            return Disposables.create()
        }
    }

    /**
     removeConnections
     - DELETE /connect/{providerId}
     - examples: [{output=none}]
     
     - parameter xAPPVersion: (header) app version 
     - parameter xDevice: (header) device/os information (informal) 
     - parameter acceptLanguage: (header) language-locale 
     - parameter providerId: (path) providerId 

     - returns: RequestBuilder<RedirectView> 
     */
    open class func removeConnectionsUsingDELETEWithRequestBuilder(xAPPVersion: String, xDevice: String, acceptLanguage: String, providerId: String) -> RequestBuilder<RedirectView> {
        var path = "/connect/{providerId}"
        path = path.replacingOccurrences(of: "{providerId}", with: "\(providerId)", options: .literal, range: nil)
        let URLString = BoostMINIAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            "X-APP-Version": xAPPVersion,
            "X-Device": xDevice,
            "Accept-Language": acceptLanguage
        ]
        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RedirectView>.Type = BoostMINIAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false, headers: headerParameters)
    }

}
